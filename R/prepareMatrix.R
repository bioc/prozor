.makePeptideID <- function(peprot){
    tmp = peprot[,c("peptideModSequence","z")]
    tmp = apply(tmp,2,as.character)
    apply(tmp, 1, paste, collapse = '.')
}
#' given table of peptide protein assigments generate matrix
#' @param data generated by annotatePeptides
#' @value sparse matrix
#' @export
#' @example
#' data(prottabmeta)
#' library(Matrix)
#' colnames(prottabmeta)
#' dim(prottabmeta)
#' xx = prepareMatrix(prottabmeta, weight= "count")
#' #xx = prepareMatrix(prottabmeta, weight = "AA")
#' #xx = prepareMatrix(prottabmeta, weight = "coverage")
#' image(as.matrix(xx[1:300,1:300]))
#' tmp = cor(as.matrix(xx))
#' par(mfrow =c(2,1))
#' image(tmp[1:300,1:300])
#' rownames(tmp[1:300,1:300])
#' dim(xx)
#' # penalise peptides matching many proteins
#' xxn = t(apply(xx, 1, function(x){x/sum(x)}))
#' dim(xxn)
#' tmpn = cor(as.matrix(xxn))
#' image(tmpn[1:300,1:300])
#' rownames(tmpn[1:300,1:300])
prepareMatrix <- function(data, weight = "count" ){
    fprots = as.factor(data[,"proteinID"])
    prots = as.integer(fprots)
    fpeps = as.factor(prozor:::.makePeptideID(data))
    peps = as.integer(fpeps)

    if(weight=="count"){
        pepProt =sparseMatrix(peps , prots, x = 1 )
    } else if(weight == "AA") {
        pepProt = sparseMatrix(peps, prots, x = data[,"lengthPeptide"] )
    } else if(weight == "coverage"){
        pepProt = sparseMatrix(peps, prots, x = data[,"lengthPeptide"] / data[,"lengthProtein"] )
    } else {
        stopifnot(FALSE)
    }
    colnames(pepProt) <- levels(fprots)
    rownames(pepProt) <- levels(fpeps)
    dim(pepProt)
    return(pepProt)
}

